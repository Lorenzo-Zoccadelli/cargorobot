System ioport


Event		rilevazioneDistanza		:	rilevazioneDistanza(X)
Event		rilDistContainer		:	rilDistContainer(X)
Event		rilDistAnomalia			:	rilDistAnomalia(X)
Event		rilDistVuoto			:	rilDistFineAnomalia(X)
   
///////////////////
//MALFUNZIONAMENTO
///////////////////
Event		rilevazioneAnomalia			:	rilevazioneAnomalia(X)
Event		risoluzioneAnomalia			:	risoluzioneAnomalia(X)
            
//////////////////
//RILEVAZIONE CONTAINER
//////////////////
Event 		containerRilevato			:	containerRilevato(X)

//INTERNI
Dispatch 	continue : continue(X)

Context ctx_cargoservice	ip[host="cargoservice" port=9091]
Context ctx_cargorobot		ip[host="cargorobot" port=9092]
Context ctx_ioport			ip[host="localhost" port=9093]


ExternalQActor cargoservice context ctx_cargoservice
ExternalQActor corgorobot context ctx_cargorobot


QActor lettore_sonar_fisico context ctx_ioport{
	import "main.java.utils.*"
	
	 
	[#
		
		val PYTHON_CMD = ProcessUtils.getStringEnvVar("PYTHON_CMD").orElse("")
		if(PYTHON_CMD.equals("")){
			System.out.println("La variabile d'ambiente PYTHON_CMD non è impostata")
			System.exit(1)
		}
		
		val SONAR_SCRIPT_PATH = ProcessUtils.getStringEnvVar("SONAR_SCRIPT_PATH").orElse("")
		if(SONAR_SCRIPT_PATH.equals("")){
			System.out.println("La variabile d'ambiente SONAR_SCRIPT_PATH non è impostata")
			System.exit(1)
		}
		
		if(!java.io.File(SONAR_SCRIPT_PATH).isFile()){
			System.out.println("La variabile d'ambiente SONAR_SCRIPT_PATH contiene un percorso inesistente")
			System.exit(1)
		}
		
		val process = Runtime.getRuntime().exec(PYTHON_CMD + " -u " + SONAR_SCRIPT_PATH) 
    	val reader = java.io.BufferedReader(java.io.InputStreamReader(process.inputStream))
    	
    	
	#]
	
	 
	
	State init initial{
		println("$name: STARTING...") color yellow
		
	}
	Goto working
	
	State working{
		
		[#
			val line = reader.readLine()
			
			if(line == null){
				System.out.println("Problema rilevamento distanza, line nulla")
				println(line)
				System.exit(1)
			}
			
			val D = line.toDoubleOrNull() ?: -1.0
			
			if(D<0){
				System.out.println("Problema rilevamento distanza, distanza negativa")
				System.out.println("$D")	
				System.out.println(line)
				System.exit(1)
			}
			
		#]
		
		
		//println("$name: D=${D}") color yellow
		delay 1000
		println(D) color cyan
		emitlocalstream rilevazioneDistanza : rilevazioneDistanza($D)
	}
	Goto working
}






QActor sonar context ctx_ioport{
	
	import "main.java.utils.*"
	
	[#
		
		val DFREE_CALIBRATION_FLAG = ProcessUtils.getIntEnvVar("DFREE_CALIBRATION_FLAG").orElse(0)
		var DFREE = -1.0
		if(DFREE_CALIBRATION_FLAG == 0){
			DFREE = ProcessUtils.getDoubleEnvVar("DFREE").orElse(-1.0)
			if(DFREE<0.0){
				println("Variabile d'ambiente DFREE non presente o errata")
				System.exit(1)
			}
		}
		
		val SONAR_MIS_PER_SEC=ProcessUtils.getIntEnvVar("SONAR_MIS_PER_SEC").orElse(-1)

		if(SONAR_MIS_PER_SEC<0){
			println("Variabile d'ambiente SONAR_MIS_PER_SEC non presente o errata")
			System.exit(1)
		}
		
		val TargetCounterCalibrazione = SONAR_MIS_PER_SEC * 10
		
		var counterCalibrazione = 0
	#]
	
	State init initial{
		println("$name: STARTING...") color yellow
		
		if [# DFREE_CALIBRATION_FLAG == 0 #]{
			println("$name: DFREE=${DFREE}") color yellow
		}
		
		subscribeTo lettore_sonar_fisico for rilevazioneDistanza
	}
	Transition t0
		whenEvent rilevazioneDistanza and [# DFREE_CALIBRATION_FLAG == 0 #] -> waitMisurazioni
		whenEvent rilevazioneDistanza and [# DFREE_CALIBRATION_FLAG == 1 #] -> calibrazione
	
	
	State calibrazione{
		onMsg(rilevazioneDistanza : rilevazioneDistanza(X)){
			[#
				val D = payloadArg(0).toDouble()
			#]
			
			println("$name: calibrazione in corso [${counterCalibrazione}/${TargetCounterCalibrazione}]...") color yellow
			if [# counterCalibrazione < TargetCounterCalibrazione #]{
				[#
					if(D > DFREE){
						DFREE = D
					}
					counterCalibrazione += 1
				#]
			}
			else{
				[#
					//DFREE = DFREE/TargetCounterCalibrazione
				#]
				autodispatch continue : continue(1)
			}
			
		}
	}
	Transition t0
		whenMsg continue -> endCalibrazione
		whenEvent rilevazioneDistanza -> calibrazione
	
	State endCalibrazione{
		println("$name: calibrazione terminata, DFREE=${DFREE}") color yellow
	}
	Transition t0
		whenEvent rilevazioneDistanza -> waitMisurazioni
	
	State waitMisurazioni {
		onMsg(rilevazioneDistanza : rilevazioneDistanza(X)){
			[#
				val D = payloadArg(0).toDouble()
			#]
			
			println("$name: ricevuto D=${D}") color yellow
			
			if [# D <= DFREE/2 #] {
				emitlocalstream rilDistContainer : rilDistContainer(1)
			}
			else{
				if [# D > DFREE #] {
					emitlocalstream rilDistAnomalia : rilDistAnomalia(1)
				}
				else{
					emitlocalstream rilDistVuoto : rilDistVuoto(1)
				}
			}
			
		}
	}
	Transition t0
		whenEvent rilevazioneDistanza -> waitMisurazioni
}









QActor ioport context ctx_ioport{
	
	import "main.java.utils.*"
	
	[# 
		var contatore = 0 
	
		
		val RIL_CONTAINER_SECS=ProcessUtils.getIntEnvVar("RIL_CONTAINER_SECS").orElse(3)
		val RIL_ANOMALIA_SECS=ProcessUtils.getIntEnvVar("RIL_ANOMALIA_SECS").orElse(3)
		val SONAR_MIS_PER_SEC=ProcessUtils.getIntEnvVar("SONAR_MIS_PER_SEC").orElse(-1)

		if(SONAR_MIS_PER_SEC<0){
			println("Variabile d'ambiente SONAR_MIS_PER_SEC non presente o errata")
			System.exit(1)
		}
		
		val ContainerCounterTarget = SONAR_MIS_PER_SEC * RIL_CONTAINER_SECS
		val AnomaliaTargetCounter = SONAR_MIS_PER_SEC * RIL_ANOMALIA_SECS
		
	
	#]
	
	State init initial{
		println("$name: STARTING...") color yellow
		
		subscribeTo sonar for rilDistContainer
		subscribeTo sonar for rilDistAnomalia
		subscribeTo sonar for rilDistVuoto
	}
	Goto ioportVuota
	
	State ioportVuota{
		println("$name: ioport vuota...") color yellow
	}
	Transition t0
		whenEvent rilDistContainer -> resetPerContainer
		whenEvent rilDistAnomalia -> resetPerAnomalia
	
	
	
	State resetPerContainer{
		[# contatore = 0 #]
	}
	Goto checkContainer
	
	State checkContainer{
		[# contatore += 1 #]
		if [# contatore == ContainerCounterTarget #]{
			[# contatore = 0 #]
			emit containerRilevato : containerRilevato(1)
			autodispatch continue : continue(1)
		}
	}
	Transition t0
		whenMsg continue -> containerRilevato
		whenEvent rilDistContainer -> checkContainer
		whenEvent rilDistAnomalia -> resetPerAnomalia
		whenEvent rilDistVuoto -> ioportVuota
		
	State containerRilevato{
		println("$name: container rilevato") color yellow
	}
	Transition t0
		whenEvent rilDistAnomalia -> resetPerAnomalia
		whenEvent rilDistVuoto -> ioportVuota
	
	
	State resetPerAnomalia{
		[# contatore = 0 #]
	}
	Goto checkAnomalia
	
	State checkAnomalia{
		[# contatore += 1 #]
		if [# contatore == AnomaliaTargetCounter #]{
			[# contatore = 0 #]
			emit rilevazioneAnomalia : rilevazioneAnomalia(1)
			autodispatch continue : continue(1)
		}
	}
	Transition t0
		whenMsg continue -> anomalia
		whenEvent rilDistContainer -> resetPerContainer
		whenEvent rilDistAnomalia -> checkAnomalia
		whenEvent rilDistVuoto -> ioportVuota
	
	State anomalia{
		println("$name: anomalia in corso") color yellow
	}
	Transition t0
		whenEvent rilDistVuoto -> fineAnomalia
		
	State fineAnomalia{
		println("$name: fine anomalia") color yellow
		emit risoluzioneAnomalia : risoluzioneAnomalia(1)
	}
	Goto ioportVuota
	
}





QActor led context ctx_ioport{
	import "java.io.*"
	import "main.java.utils.*"
	
	[#
		val PYTHON_CMD = System.getenv("PYTHON_CMD") ?: ""
		if(PYTHON_CMD.equals("")){
			System.out.println("La variabile d'ambiente PYTHON_CMD non è impostata")
			System.exit(1)
		}
		
		val LED_ON_SCRIPT_PATH = System.getenv("LED_ON_SCRIPT_PATH") ?: ""
		val LED_OFF_SCRIPT_PATH = System.getenv("LED_OFF_SCRIPT_PATH") ?: ""
		if(LED_ON_SCRIPT_PATH.equals("") || LED_OFF_SCRIPT_PATH.equals("")){
			System.out.println("Le variabili d'ambiente LED_ON_SCRIPT_PATH e LED_OFF_SCRIPT_PATH non sono impostate")
			System.exit(1)
		}
		
		if(!File(LED_ON_SCRIPT_PATH).isFile() || !File(LED_OFF_SCRIPT_PATH).isFile()){
			System.out.println("Le variabili d'ambiente LED_ON_SCRIPT_PATH e LED_OFF_SCRIPT_PATH contengono percorsi inesistenti")
			System.exit(1)
		}
		 
	#]
	
	
	State init initial{
		println("$name: STARTING...") color yellow
	}
	Goto ledOff
	 
	State ledOff{
		//spegnimento led
		[# 
			val process = Runtime.getRuntime().exec(PYTHON_CMD+" "+LED_OFF_SCRIPT_PATH)
			val ledFisicoMsg = "led fisico: " + ProcessUtils.readAllStdOutput(process)
		#]
		println(ledFisicoMsg) color yellow
		
		println("$name: led spento") color yellow
	}
	Transition t0
		whenEvent rilevazioneAnomalia -> ledOn
		
	
	State ledOn{
		//accensione led
		[# 
			val process = Runtime.getRuntime().exec(PYTHON_CMD+" "+LED_ON_SCRIPT_PATH)
			val ledFisicoMsg = "led fisico: " + ProcessUtils.readAllStdOutput(process)
		#]
		println(ledFisicoMsg) color yellow
		println("$name: led acceso") color yellow
	}
	Transition t0
		whenEvent risoluzioneAnomalia -> ledOff	
}